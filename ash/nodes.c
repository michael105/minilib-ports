/*
 * This file was generated by mknodes.sh
 */

/*	$NetBSD: nodes.c.pat,v 1.14 2018/06/22 11:04:55 kre Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Kenneth Almquist.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nodes.c.pat	8.2 (Berkeley) 5/4/95
 */

//#include <stdlib.h>
//#include <stdlib.h>
//#include <stddef.h>
//#include <stddef.h>

/*
 * Routine for dealing with parsed shell commands.
 */

#include "shell.h"
#include "nodes.h"
#include "memalloc.h"
#include "machdep.h"
#include "mystring.h"


/* used to accumulate sizes of nodes */
struct nodesize {
	int bsize;		/* size of structures in function */
	int ssize;		/* size of strings in node */
};

/* provides resources for node copies */
struct nodecopystate {
	pointer block;		/* block to allocate function from */
	char *string;		/* block to allocate strings from */
};


static const short nodesize[28] = {
      SHELL_ALIGN(sizeof (struct nbinary)),
      SHELL_ALIGN(sizeof (struct ncmd)),
      SHELL_ALIGN(sizeof (struct npipe)),
      SHELL_ALIGN(sizeof (struct nredir)),
      SHELL_ALIGN(sizeof (struct nredir)),
      SHELL_ALIGN(sizeof (struct nredir)),
      SHELL_ALIGN(sizeof (struct nbinary)),
      SHELL_ALIGN(sizeof (struct nbinary)),
      SHELL_ALIGN(sizeof (struct nif)),
      SHELL_ALIGN(sizeof (struct nbinary)),
      SHELL_ALIGN(sizeof (struct nbinary)),
      SHELL_ALIGN(sizeof (struct nfor)),
      SHELL_ALIGN(sizeof (struct ncase)),
      SHELL_ALIGN(sizeof (struct nclist)),
      SHELL_ALIGN(sizeof (struct nclist)),
      SHELL_ALIGN(sizeof (struct narg)),
      SHELL_ALIGN(sizeof (struct narg)),
      SHELL_ALIGN(sizeof (struct nfile)),
      SHELL_ALIGN(sizeof (struct nfile)),
      SHELL_ALIGN(sizeof (struct nfile)),
      SHELL_ALIGN(sizeof (struct nfile)),
      SHELL_ALIGN(sizeof (struct nfile)),
      SHELL_ALIGN(sizeof (struct ndup)),
      SHELL_ALIGN(sizeof (struct ndup)),
      SHELL_ALIGN(sizeof (struct nhere)),
      SHELL_ALIGN(sizeof (struct nhere)),
      SHELL_ALIGN(sizeof (struct nnot)),
      SHELL_ALIGN(sizeof (struct nnot)),
};



STATIC void calcsize(union node *, struct nodesize *);
STATIC void sizenodelist(struct nodelist *, struct nodesize *);
STATIC union node *copynode(union node *, struct nodecopystate *);
STATIC struct nodelist *copynodelist(struct nodelist *, struct nodecopystate *);
STATIC char *nodesavestr(char *, struct nodecopystate *);

struct funcdef {
	unsigned int refcount;
	union node n;		/* must be last */
};


/*
 * Make a copy of a parse tree.
 */

struct funcdef *
copyfunc(union node *n)
{
	struct nodesize sz;
	struct nodecopystate st;
	struct funcdef *fn;

	if (n == NULL)
		return NULL;
	sz.bsize = offsetof(struct funcdef, n);
	//sz.bsize = sizeof( unsigned int ) + 1;

	sz.ssize = 0;
	calcsize(n, &sz);
	fn = ckmalloc(sz.bsize + sz.ssize);
	fn->refcount = 1;
	st.block = (char *)fn + offsetof(struct funcdef, n);
	//st.block = (char *)fn + sizeof( unsigned int ) + 1; //offsetof(struct funcdef, n);
	st.string = (char *)fn + sz.bsize;
	copynode(n, &st);
	return fn;
}

union node *
getfuncnode(struct funcdef *fn)
{
	if (fn == NULL)
		return NULL;
	return &fn->n;
}


STATIC void
calcsize(union node *n, struct nodesize *res)
{
      if (n == NULL)
	    return;
      res->bsize += nodesize[n->type];
      switch (n->type) {
      case NSEMI:
      case NAND:
      case NOR:
      case NWHILE:
      case NUNTIL:
	    calcsize(n->nbinary.ch2, res);
	    calcsize(n->nbinary.ch1, res);
	    break;
      case NCMD:
	    calcsize(n->ncmd.redirect, res);
	    calcsize(n->ncmd.args, res);
	    break;
      case NPIPE:
	    sizenodelist(n->npipe.cmdlist, res);
	    break;
      case NREDIR:
      case NBACKGND:
      case NSUBSHELL:
	    calcsize(n->nredir.redirect, res);
	    calcsize(n->nredir.n, res);
	    break;
      case NIF:
	    calcsize(n->nif.elsepart, res);
	    calcsize(n->nif.ifpart, res);
	    calcsize(n->nif.test, res);
	    break;
      case NFOR:
	    res->ssize += strlen(n->nfor.var) + 1;
	    calcsize(n->nfor.body, res);
	    calcsize(n->nfor.args, res);
	    break;
      case NCASE:
	    calcsize(n->ncase.cases, res);
	    calcsize(n->ncase.expr, res);
	    break;
      case NCLISTCONT:
      case NCLIST:
	    calcsize(n->nclist.body, res);
	    calcsize(n->nclist.pattern, res);
	    calcsize(n->nclist.next, res);
	    break;
      case NDEFUN:
      case NARG:
	    sizenodelist(n->narg.backquote, res);
	    res->ssize += strlen(n->narg.text) + 1;
	    calcsize(n->narg.next, res);
	    break;
      case NTO:
      case NCLOBBER:
      case NFROM:
      case NFROMTO:
      case NAPPEND:
	    calcsize(n->nfile.fname, res);
	    calcsize(n->nfile.next, res);
	    break;
      case NTOFD:
      case NFROMFD:
	    calcsize(n->ndup.vname, res);
	    calcsize(n->ndup.next, res);
	    break;
      case NHERE:
      case NXHERE:
	    calcsize(n->nhere.doc, res);
	    calcsize(n->nhere.next, res);
	    break;
      case NNOT:
      case NDNOT:
	    calcsize(n->nnot.com, res);
	    break;
      };
}



STATIC void
sizenodelist(struct nodelist *lp, struct nodesize *res)
{
	while (lp) {
		res->bsize += SHELL_ALIGN(sizeof(struct nodelist));
		calcsize(lp->n, res);
		lp = lp->next;
	}
}



STATIC union node *
copynode(union node *n, struct nodecopystate *st)
{
	union node *new;

      if (n == NULL)
	    return NULL;
      new = st->block;
      st->block = (char *) st->block + nodesize[n->type];
      switch (n->type) {
      case NSEMI:
      case NAND:
      case NOR:
      case NWHILE:
      case NUNTIL:
	    new->nbinary.ch2 = copynode(n->nbinary.ch2, st);
	    new->nbinary.ch1 = copynode(n->nbinary.ch1, st);
	    break;
      case NCMD:
	    new->ncmd.lineno = n->ncmd.lineno;
	    new->ncmd.redirect = copynode(n->ncmd.redirect, st);
	    new->ncmd.args = copynode(n->ncmd.args, st);
	    new->ncmd.backgnd = n->ncmd.backgnd;
	    break;
      case NPIPE:
	    new->npipe.cmdlist = copynodelist(n->npipe.cmdlist, st);
	    new->npipe.backgnd = n->npipe.backgnd;
	    break;
      case NREDIR:
      case NBACKGND:
      case NSUBSHELL:
	    new->nredir.redirect = copynode(n->nredir.redirect, st);
	    new->nredir.n = copynode(n->nredir.n, st);
	    break;
      case NIF:
	    new->nif.elsepart = copynode(n->nif.elsepart, st);
	    new->nif.ifpart = copynode(n->nif.ifpart, st);
	    new->nif.test = copynode(n->nif.test, st);
	    break;
      case NFOR:
	    new->nfor.var = nodesavestr(n->nfor.var, st);
	    new->nfor.body = copynode(n->nfor.body, st);
	    new->nfor.args = copynode(n->nfor.args, st);
	    break;
      case NCASE:
	    new->ncase.lineno = n->ncase.lineno;
	    new->ncase.cases = copynode(n->ncase.cases, st);
	    new->ncase.expr = copynode(n->ncase.expr, st);
	    break;
      case NCLISTCONT:
      case NCLIST:
	    new->nclist.lineno = n->nclist.lineno;
	    new->nclist.body = copynode(n->nclist.body, st);
	    new->nclist.pattern = copynode(n->nclist.pattern, st);
	    new->nclist.next = copynode(n->nclist.next, st);
	    break;
      case NDEFUN:
      case NARG:
	    new->narg.lineno = n->narg.lineno;
	    new->narg.backquote = copynodelist(n->narg.backquote, st);
	    new->narg.text = nodesavestr(n->narg.text, st);
	    new->narg.next = copynode(n->narg.next, st);
	    break;
      case NTO:
      case NCLOBBER:
      case NFROM:
      case NFROMTO:
      case NAPPEND:
	    new->nfile.fname = copynode(n->nfile.fname, st);
	    new->nfile.fd = n->nfile.fd;
	    new->nfile.next = copynode(n->nfile.next, st);
	    break;
      case NTOFD:
      case NFROMFD:
	    new->ndup.vname = copynode(n->ndup.vname, st);
	    new->ndup.dupfd = n->ndup.dupfd;
	    new->ndup.fd = n->ndup.fd;
	    new->ndup.next = copynode(n->ndup.next, st);
	    break;
      case NHERE:
      case NXHERE:
	    new->nhere.doc = copynode(n->nhere.doc, st);
	    new->nhere.fd = n->nhere.fd;
	    new->nhere.next = copynode(n->nhere.next, st);
	    break;
      case NNOT:
      case NDNOT:
	    new->nnot.com = copynode(n->nnot.com, st);
	    break;
      };
      new->type = n->type;
	return new;
}


STATIC struct nodelist *
copynodelist(struct nodelist *lp, struct nodecopystate *st)
{
	struct nodelist *start;
	struct nodelist **lpp;

	lpp = &start;
	while (lp) {
		*lpp = st->block;
		st->block = (char *)st->block +
		    SHELL_ALIGN(sizeof(struct nodelist));
		(*lpp)->n = copynode(lp->n, st);
		lp = lp->next;
		lpp = &(*lpp)->next;
	}
	*lpp = NULL;
	return start;
}



STATIC char *
nodesavestr(char *s, struct nodecopystate *st)
{
	register char *p = s;
	register char *q = st->string;
	char   *rtn = st->string;

	while ((*q++ = *p++) != 0)
		continue;
	st->string = q;
	return rtn;
}



/*
 * Handle making a reference to a function, and releasing it.
 * Free the func code when there are no remaining references.
 */

void
reffunc(struct funcdef *fn)
{
	if (fn != NULL)
		fn->refcount++;
}

void
unreffunc(struct funcdef *fn)
{
	if (fn != NULL) {
		if (--fn->refcount > 0)
			return;
		ckfree(fn);
	}
}

/*
 * this is used when we need to free the func, regardless of refcount
 * which only happens when re-initing the shell for a SHELLPROC
 */
void
freefunc(struct funcdef *fn)
{
	if (fn != NULL)
		ckfree(fn);
}
